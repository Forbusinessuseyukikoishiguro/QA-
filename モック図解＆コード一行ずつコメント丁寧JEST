モック実装のコードを一行ずつ詳しく解説します！新人エンジニアが完全に理解できるように図解とコメント付きで説明しますね。

## 🔍 **Pattern 1: 単純な関数モック（完全解説）**

```javascript
// ❌ 初心者がやりがちな間違い
const wrapper = mount(Component)
//    ↑          ↑       ↑
//    │          │       └─ Vue コンポーネントクラス
//    │          └─ @vue/test-utils の関数（DOM に仮想マウント）
//    └─ マウントされたコンポーネントのラッパーオブジェクト

wrapper.vm.calcAmount() // 実際の計算が実行されてしまう
//      ↑   ↑
//      │   └─ コンポーネント内のメソッド
//      └─ Vue インスタンスへの参照

// ✅ 正しいモック実装
const wrapper = mount(Component)
//    ↑          ↑       ↑
//    │          │       └─ 同じコンポーネント
//    │          └─ 同じマウント処理
//    └─ 同じラッパーオブジェクト

wrapper.vm.calcAmount = jest.fn() // モック化
//      ↑   ↑            ↑    ↑
//      │   │            │    └─ Jest のモック関数作成
//      │   │            └─ Jest テストフレームワーク
//      │   └─ 元のメソッドを置き換え
//      └─ Vue インスタンス

wrapper.vm.calcAmount() // 実行されるが、実際の処理はしない
//      ↑   ↑
//      │   └─ モック化されたメソッド（偽物）
//      └─ 呼び出しは記録されるが、元の処理は実行されない

// 検証
expect(wrapper.vm.calcAmount).toHaveBeenCalled() // 呼ばれたかチェック
//↑    ↑        ↑               ↑
//│    │        │               └─ Jest マッチャー（呼び出し確認）
//│    │        └─ モック化されたメソッド
//│    └─ テスト対象のコンポーネント
//└─ Jest のアサーション関数
```

### **実行フロー図解**

```
【❌ 間違いパターン】
wrapper.vm.calcAmount() を実行
         ↓
本物のcalcAmountメソッドが動く
         ↓
複雑な計算処理が実行される
         ↓
他のメソッドも連鎖的に呼ばれる
         ↓
テストが重くなる・不安定になる

【✅ 正しいパターン】  
wrapper.vm.calcAmount = jest.fn()
         ↓
元のメソッドが偽物に置き換わる
         ↓
wrapper.vm.calcAmount() を実行
         ↓
実際の処理は実行されない
         ↓
呼び出されたことだけ記録される
         ↓
expect().toHaveBeenCalled() で検証
```

---

## 🔄 **Pattern 2: 戻り値付きモック（詳細解説）**

```javascript
describe('保険料計算テスト', () => {
//↑       ↑                 ↑
//│       │                 └─ アロー関数（テストグループの処理）
//│       └─ テストスイートの説明文
//└─ Jest のテストグループ化関数

  it('プラン変更時に保険料が更新される', async () => {
  //↑ ↑                           ↑      ↑
  //│ │                           │      └─ 非同期関数（awaitを使うため）
  //│ │                           └─ アロー関数
  //│ └─ 個別テストケースの説明
  //└─ Jest の個別テスト関数

    const wrapper = mount(ProductDetailSumameRabbit, {
    //    ↑          ↑    ↑                      ↑
    //    │          │    │                      └─ マウント時のオプション
    //    │          │    └─ 実際のコンポーネント名
    //    │          └─ Vue Test Utils の関数
    //    └─ マウント結果を格納する変数

      propsData: { /* テストデータ */ }
      //↑        ↑
      //│        └─ 親コンポーネントから渡されるデータ
      //└─ Vue Test Utils のオプション名
    })
    
    // ✅ 計算メソッドをモック化して戻り値を固定
    wrapper.vm.calcAmount = jest.fn().mockReturnValue(1500)
    //      ↑   ↑            ↑    ↑    ↑              ↑
    //      │   │            │    │    │              └─ 固定の戻り値
    //      │   │            │    │    └─ 戻り値を設定するメソッド
    //      │   │            │    └─ Jest モック関数
    //      │   │            └─ Jest フレームワーク
    //      │   └─ メソッド名
    //      └─ Vue インスタンス
    
    // プラン変更をシミュレート
    wrapper.find('select[name="product_09_01"]').setValue('3')
    //      ↑    ↑                            ↑        ↑
    //      │    │                            │        └─ 設定する値
    //      │    │                            └─ 値を設定するメソッド
    //      │    └─ CSS セレクター（name属性で要素を特定）
    //      └─ DOM 要素を検索するメソッド

    await wrapper.vm.$nextTick()
    //↑   ↑        ↑  ↑
    //│   │        │  └─ Vue の DOM 更新完了を待つメソッド
    //│   │        └─ Vue インスタンス
    //│   └─ マウントされたコンポーネント
    //└─ 非同期処理の完了を待つ
    
    // モックが呼ばれたことを確認
    expect(wrapper.vm.calcAmount).toHaveBeenCalled()
    //↑    ↑        ↑   ↑           ↑
    //│    │        │   │           └─ 「呼び出された」ことを確認するマッチャー
    //│    │        │   └─ モック化されたメソッド
    //│    │        └─ Vue インスタンス
    //│    └─ ラッパーオブジェクト
    //└─ Jest のアサーション関数
  })
})
```

### **詳細実行フロー図解**

```
ステップ1: コンポーネントマウント
┌─────────────────────────────────┐
│ const wrapper = mount(Component)│
└─────────────────────────────────┘
                ↓
┌─────────────────────────────────┐
│    仮想DOM上にコンポーネント作成   │
│   • data プロパティ初期化        │
│   • methods の準備             │
│   • template のレンダリング      │
└─────────────────────────────────┘

ステップ2: メソッドのモック化
┌─────────────────────────────────┐
│wrapper.vm.calcAmount = jest.fn()│
│             .mockReturnValue()  │
└─────────────────────────────────┘
                ↓
┌─────────────────────────────────┐
│  元のcalcAmountメソッド = 複雑な計算│
│            ↓ 置き換え            │
│  新しいcalcAmount = 常に1500を返す │
└─────────────────────────────────┘

ステップ3: ユーザー操作のシミュレート
┌─────────────────────────────────┐
│wrapper.find('select').setValue()│
└─────────────────────────────────┘
                ↓
┌─────────────────────────────────┐
│ セレクトボックスの値が変更される    │
│           ↓                    │
│ @change イベントが発火           │
│           ↓                    │
│ calcAmount() が呼び出される      │
└─────────────────────────────────┘

ステップ4: DOM更新の待機
┌─────────────────────────────────┐
│   await wrapper.vm.$nextTick()  │
└─────────────────────────────────┘
                ↓
┌─────────────────────────────────┐
│ Vue の次の更新サイクルまで待機     │
│ • データ変更の反映完了            │
│ • DOM の再レンダリング完了        │
└─────────────────────────────────┘

ステップ5: 検証
┌─────────────────────────────────┐
│expect().toHaveBeenCalled()     │
└─────────────────────────────────┘
                ↓
┌─────────────────────────────────┐
│ モック関数の呼び出し履歴をチェック  │
│ ✅ 1回呼ばれた → テスト成功       │
│ ❌ 呼ばれてない → テスト失敗      │
└─────────────────────────────────┘
```

---

## 🗃️ **Pattern 3: Vuexストアモック（超詳細）**

```javascript
// ❌ 実際のVuexストアを使う（複雑で壊れやすい）
import store from '@/store'
//↑    ↑     ↑    ↑
//│    │     │    └─ ストアファイルのパス
//│    │     └─ import元指定
//│    └─ インポートされるオブジェクト名
//└─ ES6のインポート構文

const wrapper = mount(Component, { store })
//    ↑          ↑    ↑           ↑ ↑
//    │          │    │           │ └─ 実際のVuexストア（重い）
//    │          │    │           └─ オブジェクトショートハンド { store: store }
//    │          │    └─ テスト対象コンポーネント
//    │          └─ Vue Test Utils のマウント関数
//    └─ マウント結果

// ✅ モックストアを使う（シンプルで安定）
const mockStore = {
//    ↑         ↑
//    │         └─ 普通のJavaScriptオブジェクト
//    └─ ストアの偽物

  getters: {
  //↑      ↑
  //│      └─ オブジェクトリテラル開始
  //└─ Vuex の getters プロパティ

    'user/isLoggedIn': jest.fn().mockReturnValue(true),
    //↑               ↑    ↑    ↑              ↑
    //│               │    │    │              └─ 常にtrueを返す
    //│               │    │    └─ 戻り値設定メソッド
    //│               │    └─ Jest モック関数
    //│               └─ Jest フレームワーク
    //└─ getter名（モジュール/getter形式）

    'simulation/situation': jest.fn().mockReturnValue({
    //↑                   ↑    ↑    ↑              ↑
    //│                   │    │    │              └─ オブジェクト戻り値開始
    //│                   │    │    └─ 戻り値設定
    //│                   │    └─ モック関数
    //│                   └─ Jest
    //└─ 別のgetter名

      sumameRabbit: {
      //↑           ↑
      //│           └─ ネストしたオブジェクト
      //└─ プロパティ名

        plan: 3,
        //↑   ↑
        //│   └─ プラン番号（数値）
        //└─ プロパティ名

        payMethodTimesCode: "01"
        //↑                 ↑
        //│                 └─ 支払い方法コード（文字列）
        //└─ プロパティ名
      }
    })
  },
  dispatch: jest.fn(),
  //↑       ↑    ↑
  //│       │    └─ 引数なしモック関数
  //│       └─ Jest モック
  //└─ Vuex の action 実行メソッド

  commit: jest.fn()
  //↑     ↑    ↑
  //│     │    └─ 引数なしモック関数
  //│     └─ Jest モック
  //└─ Vuex の mutation 実行メソッド
}

const wrapper = mount(Component, {
//    ↑          ↑    ↑           ↑
//    │          │    │           └─ マウントオプション開始
//    │          │    └─ コンポーネント
//    │          └─ マウント関数
//    └─ 結果格納変数

  mocks: { $store: mockStore }
  //↑    ↑ ↑       ↑
  //│    │ │       └─ 上で作成したモックストア
  //│    │ └─ Vue インスタンスの$storeプロパティ
  //│    └─ オブジェクトリテラル
  //└─ Vue Test Utils のmocksオプション
})
```

### **Vuexストアモック動作図解**

```
【❌ 実際のストア使用】
mount(Component, { store })
         ↓
実際のVuexストアがマウントされる
         ↓
┌─────────────────────────────────┐
│  Real Vuex Store               │
│  ├─ state (大量のデータ)         │
│  ├─ getters (複雑な計算)        │
│  ├─ mutations (状態変更)        │
│  ├─ actions (非同期処理)        │
│  └─ modules (他のストア)        │
└─────────────────────────────────┘
         ↓
テストが重い・不安定・依存関係が複雑

【✅ モックストア使用】
mount(Component, { mocks: { $store: mockStore } })
         ↓
偽物のストアがマウントされる
         ↓
┌─────────────────────────────────┐
│  Mock Store                    │
│  ├─ getters: jest.fn()         │
│  ├─ dispatch: jest.fn()        │
│  └─ commit: jest.fn()          │
│                                │
│  💡 必要最小限のメソッドのみ      │
└─────────────────────────────────┘
         ↓
テストが軽い・安定・依存関係がシンプル
```

---

## 📅 **Pattern 5: 日付モック（行単位解説）**

```javascript
describe('年齢制限テスト', () => {
//↑       ↑               ↑
//│       │               └─ テストグループの関数
//│       └─ テストスイート名
//└─ Jest のテストグループ化

  let mockDate
  //↑ ↑
  //│ └─ モック化された日付オブジェクトを保存する変数
  //└─ ブロックスコープ変数宣言
  
  beforeEach(() => {
  //↑         ↑
  //│         └─ 各テスト前に実行される関数
  //└─ Jest のライフサイクルフック

    // ✅ 日付を2019/10/1に固定
    const fixedDate = new Date(2019, 9, 1) // 10月は9（0ベース）
    //    ↑           ↑   ↑    ↑     ↑ ↑
    //    │           │   │    │     │ └─ 日（1日）
    //    │           │   │    │     └─ 月（9 = 10月、0ベース）
    //    │           │   │    └─ 年（2019年）
    //    │           │   └─ Date コンストラクター
    //    │           └─ new演算子
    //    └─ 固定日付を保存する変数

    mockDate = jest.spyOn(global, 'Date').mockImplementation(() => fixedDate)
    //↑        ↑    ↑     ↑       ↑      ↑                  ↑     ↑
    //│        │    │     │       │      │                  │     └─ 上で作成した固定日付
    //│        │    │     │       │      │                  └─ アロー関数
    //│        │     │     │       │      └─ モック実装を置き換えるメソッド
    //│        │    │     │       └─ Date コンストラクター
    //│        │    │     └─ グローバルオブジェクト（windowオブジェクト）
    //│        │    └─ 監視(スパイ)を作成するメソッド
    //│        └─ Jest フレームワーク
    //└─ let で宣言した変数に代入
  })
  
  afterEach(() => {
  //↑        ↑
  //│        └─ 各テスト後に実行される関数
  //└─ Jest のライフサイクルフック

    // ✅ 必ずクリーンアップ
    mockDate.mockRestore()
    //↑       ↑
    //│       └─ 元の Date オブジェクトに戻すメソッド
    //└─ beforeEach で作成したモック
  })
  
  it('20歳の場合、全ての特約が表示される', () => {
  //↑ ↑                                ↑
  //│ │                                └─ テスト関数
  //│ └─ テストケースの説明
  //└─ Jest の個別テスト

    const application = {
    //    ↑           ↑
    //    │           └─ オブジェクトリテラル開始
    //    └─ テスト用データを格納する変数

      birthDate: '1999-1-1', // 20歳
      //↑        ↑
      //│        └─ 生年月日文字列
      //└─ プロパティ名

      fullAge: 20
      //↑      ↑
      //│      └─ 年齢の数値
      //└─ プロパティ名
    }
    
    const wrapper = mount(ProductDetailSumameRabbit, {
    //    ↑          ↑    ↑                      ↑
    //    │          │    │                      └─ マウントオプション
    //    │          │    └─ コンポーネント名
    //    │          └─ マウント関数
    //    └─ 結果を格納する変数

      propsData: { application }
      //↑        ↑ ↑
      //│        │ └─ 上で作成したapplicationオブジェクト
      //│        └─ オブジェクトリテラル { application: application }
      //└─ propsを渡すオプション
    })
    
    expect(wrapper.find('select[name="product_09_07"]').exists()).toBe(true)
    //↑    ↑        ↑    ↑                            ↑        ↑   ↑
    //│    │        │    │                            │        │   └─ 期待値（true）
    //│    │        │    │                            │        └─ 比較マッチャー
    //│    │        │    │                            └─ 要素の存在確認メソッド
    //│    │        │    └─ CSS属性セレクター
    //│    │        └─ DOM要素検索メソッド
    //│    └─ ラッパーオブジェクト
    //└─ Jest アサーション
  })
})
```

### **日付モック実行フロー図解**

```
【beforeEach フェーズ】
const fixedDate = new Date(2019, 9, 1)
         ↓
┌─────────────────────────────────┐
│ fixedDate = 2019年10月1日       │
└─────────────────────────────────┘
         ↓
jest.spyOn(global, 'Date').mockImplementation(...)
         ↓
┌─────────────────────────────────┐
│ 元のDateコンストラクター           │
│         ↓ 置き換え               │
│ new Date() → 常に2019/10/1      │
└─────────────────────────────────┘

【テスト実行フェーズ】
コンポーネント内で new Date() が呼ばれる
         ↓
モック化されたDateが呼ばれる
         ↓
常に 2019年10月1日 が返される
         ↓
年齢計算が一定になる (20歳)
         ↓
テスト結果が安定する

【afterEach フェーズ】
mockDate.mockRestore()
         ↓
┌─────────────────────────────────┐
│ モック化されたDate                │
│         ↓ 復元                  │
│ 元の本物のDateコンストラクター      │
└─────────────────────────────────┘
         ↓
次のテストに影響しない
```

---

## 🌐 **Pattern 7: DOM要素モック（詳細解説）**

```javascript
describe('アコーディオン機能', () => {
//↑       ↑                   ↑
//│       │                   └─ テストグループの処理
//│       └─ テスト説明
//└─ Jest テストスイート

  beforeEach(() => {
  //↑         ↑
  //│         └─ 各テスト前に実行
  //└─ Jest ライフサイクル

    // ✅ DOM要素を偽物で用意
    const mockElements = {
    //    ↑            ↑
    //    │            └─ オブジェクトリテラル
    //    └─ 偽のDOM要素を格納するオブジェクト

      sumameRabbitAccordionTarget: {
      //↑                          ↑
      //│                          └─ 偽のDOM要素オブジェクト
      //└─ DOM要素のID名

        style: { height: '0px' }
        //↑    ↑ ↑       ↑
        //│    │ │       └─ 初期高さ値
        //│    │ └─ style.heightプロパティ
        //│    └─ オブジェクトリテラル
        //└─ DOM要素のstyleプロパティ
      },
      sumameRabbitAccordionBody: {
      //↑                        ↑
      //│                        └─ 別の偽DOM要素
      //└─ 別のDOM要素ID

        clientHeight: 150
        //↑           ↑
        //│           └─ 高さの数値
        //└─ DOM要素の高さプロパティ
      }
    }
    
    // document.getElementById をモック化
    jest.spyOn(document, 'getElementById')
    //↑  ↑     ↑         ↑
    //│  │     │         └─ ブラウザのDOM検索メソッド
    //│  │     └─ documentオブジェクト
    //│  └─ スパイ作成メソッド
    //└─ Jest フレームワーク

        .mockImplementation((id) => mockElements[id])
        //↑                ↑      ↑             ↑
        //│                │      │             └─ IDに対応する偽要素を返す
        //│                │      └─ 上で作成した偽要素オブジェクト
        //│                └─ 引数（要素のID）
        //└─ モック実装置き換えメソッド
  })
  
  it('アコーディオンの高さが正しく設定される', () => {
  //↑ ↑                               ↑
  //│ │                               └─ テスト関数
  //│ └─ テストの説明
  //└─ 個別テスト

    const wrapper = mount(ProductDetailSumameRabbit)
    //    ↑          ↑    ↑
    //    │          │    └─ コンポーネント
    //    │          └─ マウント関数
    //    └─ ラッパー変数

    wrapper.vm.adjustAccordionHeight()
    //      ↑  ↑
    //      │  └─ アコーディオン高さ調整メソッド
    //      └─ Vue インスタンス
    
    // モックされた要素の高さが変更されたかチェック
    const target = document.getElementById('sumameRabbitAccordionTarget')
    //    ↑        ↑         ↑
    //    │        │         └─ モック化されたメソッド（偽要素を返す）
    //    │        └─ documentオブジェクト
    //    └─ 取得した偽要素を格納

    expect(target.style.height).toBe('150px')
    //↑    ↑      ↑     ↑      ↑   ↑
    //│    │      │     │      │   └─ 期待値
    //│    │      │     │      └─ 比較マッチャー
    //│    │      │     └─ height プロパティ
    //│    │      └─ style オブジェクト
    //│    └─ 偽のDOM要素
    //└─ Jest アサーション
  })
})
```

### **DOM要素モック動作図解**

```
【Setup フェーズ】
const mockElements = { ... }
         ↓
┌─────────────────────────────────┐
│     Mock Elements Object        │
│ ┌─────────────────────────────┐ │
│ │sumameRabbitAccordionTarget  │ │
│ │  style: { height: '0px' }   │ │
│ └─────────────────────────────┘ │
│ ┌─────────────────────────────┐ │
│ │sumameRabbitAccordionBody    │ │
│ │  clientHeight: 150          │ │
│ └─────────────────────────────┘ │
└─────────────────────────────────┘
         ↓
jest.spyOn(document, 'getElementById').mockImplementation(...)
         ↓
┌─────────────────────────────────┐
│ document.getElementById         │
│         ↓ 置き換え               │
│ (id) => mockElements[id]        │
└─────────────────────────────────┘

【テスト実行フェーズ】
wrapper.vm.adjustAccordionHeight() が呼ばれる
         ↓
メソッド内で document.getElementById('sumameRabbitAccordionTarget') が実行
         ↓
モック化された関数が動く
         ↓
mockElements['sumameRabbitAccordionTarget'] が返される
         ↓
偽のDOM要素の style.height が '150px' に設定される
         ↓
expect(target.style.height).toBe('150px') でテスト成功
```

このように一行ずつ解説することで、モックの仕組みが完全に理解できるはずです！実際にコードを書きながら確認してみてください。
